---
title: Refun-20250324
pubDate: 2025-03-24
tags: [ğŸ¡Refun]
---

ä»¥ä¸‹æ˜¯ DeepSeek ç”Ÿæˆçš„ä»£ç ï¼Œæˆ‘æ”¹äº†ä¸‹ Bugï¼š

åœ¨ Rust ä¸­å®ç°æ ‘çš„éå†é€šå¸¸æ¶‰åŠå®šä¹‰æ ‘ç»“æ„ä»¥åŠå®ç°ä¸åŒçš„éå†ç®—æ³•ï¼ˆå¦‚å‰åºã€ä¸­åºã€ååºå’Œå±‚æ¬¡éå†ï¼‰ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„ Rust å®ç°ï¼Œå±•ç¤ºå¦‚ä½•å®šä¹‰æ ‘ç»“æ„ä»¥åŠå¦‚ä½•å®ç°è¿™äº›éå†ç®—æ³•ã€‚

### 1. å®šä¹‰æ ‘ç»“æ„

é¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ ‘èŠ‚ç‚¹ç»“æ„ `TreeNode`ï¼Œå®ƒåŒ…å«ä¸€ä¸ªå€¼ä»¥åŠæŒ‡å‘å·¦å³å­èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚ç”±äº Rust çš„æ‰€æœ‰æƒæœºåˆ¶ï¼Œæˆ‘ä»¬ä½¿ç”¨ `Option<Box<TreeNode>>` æ¥è¡¨ç¤ºå¯èƒ½å­˜åœ¨çš„å­èŠ‚ç‚¹ã€‚

```rust
#[derive(Debug)]
struct TreeNode<T> {
    value: T,
    left: Option<Box<TreeNode<T>>>,
    right: Option<Box<TreeNode<T>>>,
}

impl<T> TreeNode<T> {
    fn new(value: T) -> Self {
        TreeNode {
            value,
            left: None,
            right: None,
        }
    }
}
```

### 2. å‰åºéå†

å‰åºéå†çš„é¡ºåºæ˜¯ï¼šæ ¹èŠ‚ç‚¹ -> å·¦å­æ ‘ -> å³å­æ ‘ã€‚

```rust
fn pre_order_traversal<T>(root: &Option<Box<TreeNode<T>>>) {
    if let Some(node) = root {
        println!("{}", node.value); // è®¿é—®æ ¹èŠ‚ç‚¹
        pre_order_traversal(&node.left); // é€’å½’éå†å·¦å­æ ‘
        pre_order_traversal(&node.right); // é€’å½’éå†å³å­æ ‘
    }
}
```

### 3. ä¸­åºéå†

ä¸­åºéå†çš„é¡ºåºæ˜¯ï¼šå·¦å­æ ‘ -> æ ¹èŠ‚ç‚¹ -> å³å­æ ‘ã€‚

```rust
fn in_order_traversal<T>(root: &Option<Box<TreeNode<T>>>) {
    if let Some(node) = root {
        in_order_traversal(&node.left); // é€’å½’éå†å·¦å­æ ‘
        println!("{}", node.value); // è®¿é—®æ ¹èŠ‚ç‚¹
        in_order_traversal(&node.right); // é€’å½’éå†å³å­æ ‘
    }
}
```

### 4. ååºéå†

ååºéå†çš„é¡ºåºæ˜¯ï¼šå·¦å­æ ‘ -> å³å­æ ‘ -> æ ¹èŠ‚ç‚¹ã€‚

```rust
fn post_order_traversal<T>(root: &Option<Box<TreeNode<T>>>) {
    if let Some(node) = root {
        post_order_traversal(&node.left); // é€’å½’éå†å·¦å­æ ‘
        post_order_traversal(&node.right); // é€’å½’éå†å³å­æ ‘
        println!("{}", node.value); // è®¿é—®æ ¹èŠ‚ç‚¹
    }
}
```

### 5. å±‚æ¬¡éå†

å±‚æ¬¡éå†ï¼ˆå¹¿åº¦ä¼˜å…ˆéå†ï¼‰ä½¿ç”¨é˜Ÿåˆ—æ¥å®ç°ã€‚æˆ‘ä»¬ä½¿ç”¨ `VecDeque` æ¥æ¨¡æ‹Ÿé˜Ÿåˆ—ã€‚

```rust
use std::collections::VecDeque;

fn level_order_traversal<T>(root: &Option<Box<TreeNode<T>>>) {
    if let Some(root_node) = root {
        let mut queue = VecDeque::new();
        queue.push_back(root_node);

        while !queue.is_empty() {
            let node = queue.pop_front().unwrap();
            println!("{}", node.value); // è®¿é—®å½“å‰èŠ‚ç‚¹

            if let Some(left) = &node.left {
                queue.push_back(left);
            }
            if let Some(right) = &node.right {
                queue.push_back(right);
            }
        }
    }
}
```

### 6. ç¤ºä¾‹ç”¨æ³•

ä»¥ä¸‹æ˜¯å¦‚ä½•ä½¿ç”¨ä¸Šè¿°å®šä¹‰çš„æ ‘ç»“æ„å’Œéå†ç®—æ³•çš„ç¤ºä¾‹ï¼š

```rust
fn main() {
    // æ„å»ºä¸€ä¸ªç®€å•çš„äºŒå‰æ ‘
    let mut root = TreeNode::new(1);
    root.left = Some(Box::new(TreeNode::new(2)));
    root.right = Some(Box::new(TreeNode::new(3)));
    root.left.as_mut().unwrap().left = Some(Box::new(TreeNode::new(4)));
    root.left.as_mut().unwrap().right = Some(Box::new(TreeNode::new(5)));

    println!("Pre-order traversal:");
    pre_order_traversal(&Some(Box::new(root)));

    println!("In-order traversal:");
    in_order_traversal(&Some(Box::new(root)));

    println!("Post-order traversal:");
    post_order_traversal(&Some(Box::new(root)));

    println!("Level-order traversal:");
    level_order_traversal(&Some(Box::new(root)));
}
```

### 7. è¾“å‡ºç»“æœ

è¿è¡Œä¸Šè¿°ä»£ç åï¼Œè¾“å‡ºç»“æœå¦‚ä¸‹ï¼š

```
Pre-order traversal:
1
2
4
5
3
In-order traversal:
4
2
5
1
3
Post-order traversal:
4
5
2
3
1
Level-order traversal:
1
2
3
4
5
```

### æ€»ç»“

ä»¥ä¸Šä»£ç å±•ç¤ºäº†å¦‚ä½•åœ¨ Rust ä¸­å®šä¹‰æ ‘ç»“æ„ä»¥åŠå®ç°å‰åºã€ä¸­åºã€ååºå’Œå±‚æ¬¡éå†ã€‚Rust çš„æ‰€æœ‰æƒå’Œå€Ÿç”¨æœºåˆ¶ä½¿å¾—æ ‘ç»“æ„çš„å®ç°ç›¸å¯¹å¤æ‚ï¼Œä½†é€šè¿‡ `Option<Box<TreeNode>>` å¯ä»¥æœ‰æ•ˆåœ°ç®¡ç†æ ‘èŠ‚ç‚¹çš„ç”Ÿå‘½å‘¨æœŸã€‚
